//-----------------------------------------------------------------------
// FILE    : CertificateCreator.scala
// SUBJECT : This object wraps the grunt methods that crank out the certificates themselves.
// AUTHOR  : (C) Copyright 2011 by Simone Willett <sgwillet@uvm.edu>
//                and Peter Chapin <PChapin@vtc.vsc.edu>
//
//-----------------------------------------------------------------------
package edu.uvm.rtadmin

import java.security.Signature
import java.security.interfaces.{ECPrivateKey, ECPublicKey}
import BinaryHelpers._
import Database._

/**
 * Object to wrap the low level certificate creation methods. Certificates generated by this system are in a special,
 * low overhead format defined here.
 */
object CertificateCreator {
  
  /**
   * Installs a public key into the raw array. Uncompressed public keys consume exactly 40 bytes. If compression is
   * requested only 21 bytes are used. The last byte is zero or one as appropriate to represent the Y coordinate of the
   * key. This format is not standard; the receiver must know what to expect. It does save two bytes in the uncompressed
   * case.
   * 
   * @param rawBinary The array into which the key bytes are to be placed.
   * @param targetOffset The location in the array where the first key byte is placed.
   * @param key The public key to install in the array. Only 160 bit keys are supported.
   * @param useCompressedKeys True if public key compression is in effect.
   */
  private def installPublicKey(
    rawBinary:         Array[Byte],
    targetOffset:      Int,
    key:               ECPublicKey,
    useCompressedKeys: Boolean) = {
    
    copyInto(target   = rawBinary,
             atOffset = targetOffset,
             from     = normalizeKeyValue(key.getW.getAffineX.toByteArray))
    
    val offsetAdvance = if (useCompressedKeys) {
      val keyY = key.getW.getAffineY
      rawBinary(targetOffset + 20) = if (keyY.testBit(0)) 1 else 0
      1
    }
    else {
      copyInto(target   = rawBinary,
               atOffset = targetOffset + 20,
               from     = normalizeKeyValue(key.getW.getAffineY.toByteArray))
      20
    }
    
    offsetAdvance + 20
  }
  
  /**
   * Create a certificate for a membership credential. The public and private keys of the defining entity must be
   * present in the database. The public key of the source entity and the role identifier must also be present in the
   * database.
   * 
   * @param definingEntity The name of the entity issuing this certificate.
   * @param definingRoleName The name of the role being specified by the issuing entity.
   * @param sourceEntity The name of the entity being added to the specified role.
   * @param useCompressedKeys True if the public keys should be output in compressed form.
   */
  def createMembershipCertificate(
    definingEntity:    String,
    definingRoleName:  String,
    sourceEntity:      String,
    useCompressedKeys: Boolean = false) = {
    
    var targetOffset = 0

    val definingPrivateKey = lookupPrivateKey(definingEntity)
    val definingPublicKey  = lookupPublicKey(definingEntity)
    val sourcePublicKey    = lookupPublicKey(sourceEntity)
    val definingRole       = lookupRoleID(definingRoleName)

    val rawBinary = new Array[Byte](if (useCompressedKeys) 44 else 82)

    rawBinary(targetOffset) = 1    // Certificate form identifier.
    targetOffset += 1
    targetOffset += installPublicKey(rawBinary, targetOffset, definingPublicKey, useCompressedKeys)
    rawBinary(targetOffset) = definingRole.toByte
    targetOffset += 1
    targetOffset += installPublicKey(rawBinary, targetOffset, sourcePublicKey, useCompressedKeys)
 
    val signature = createSignature(rawBinary, definingPrivateKey)
    rawBinary ++ signature
  }

  
  /**
   * Create a certificate for an inclusion credential. The public and private keys of the defining entity must be
   * present in the database. The public key of the source entity and the role identifiers must also be present in the
   * database.
   * 
   * @param definingEntity The name of the entity issuing this certificate.
   * @param definingRoleName The name of the role being specified by the issuing entity.
   * @param sourceEntity The name of the entity controlling the source role.
   * @param sourceRoleName The name of the source role.
   * @param useCompressedKeys True if the public keys should be output in compressed form.
   */
  def createInclusionCertificate(
    definingEntity:    String,
    definingRoleName:  String,
    sourceEntity:      String,
    sourceRoleName:    String,
    useCompressedKeys: Boolean = false) = {
    
    var targetOffset = 0
    
    val definingPrivateKey = lookupPrivateKey(definingEntity)
    val definingPublicKey  = lookupPublicKey(definingEntity)
    val sourcePublicKey    = lookupPublicKey(sourceEntity)
    val definingRole       = lookupRoleID(definingRoleName)
    val sourceRole         = lookupRoleID(sourceRoleName)

    val rawBinary = new Array[Byte](if (useCompressedKeys) 45 else 83)

    rawBinary(targetOffset) = 2    // Certificate form identifier.
    targetOffset += 1
    targetOffset += installPublicKey(rawBinary, targetOffset, definingPublicKey, useCompressedKeys)
    rawBinary(targetOffset) = definingRole.toByte
    targetOffset += 1
    targetOffset += installPublicKey(rawBinary, targetOffset, sourcePublicKey, useCompressedKeys)
    rawBinary(targetOffset) = sourceRole.toByte
    targetOffset += 1

    val signature = createSignature(rawBinary, definingPrivateKey)
    rawBinary ++ signature
  }

  
  /**
   * Create a certificate for linked credentials. The public and private keys of the defining entity must be present in
   * the database. The public key of the source entity and the role identifiers must also be present in the database.
   * 
   * @param definingEntity The name of the entity issuing this certificate.
   * @param definingRoleName The name of the role being specified by the issuing entity.
   * @param sourceEntity The name of the entity controlling the indirect role.
   * @param sourceRole1Name The name of the indirect role.
   * @param sourceRole2Name The name of the role from which new members are taken.
   * @param useCompressedKeys True if the public keys should be output in compressed form.
   */
  def createLinkedCertificate(
    definingEntity:    String,
    definingRoleName:  String,
    sourceEntity:      String,
    sourceRole1Name:   String,
    sourceRole2Name:   String,
    useCompressedKeys: Boolean = false) = {
    
    var targetOffset = 0

    val definingPrivateKey = lookupPrivateKey(definingEntity)
    val definingPublicKey  = lookupPublicKey(definingEntity)
    val sourcePublicKey    = lookupPublicKey(sourceEntity)
    val definingRole       = lookupRoleID(definingRoleName)
    val sourceRole1        = lookupRoleID(sourceRole1Name)
    val sourceRole2        = lookupRoleID(sourceRole2Name)
    
    val rawBinary = new Array[Byte](if (useCompressedKeys) 46 else 84)

    rawBinary(targetOffset) = 3    // Certificate form identifier.
    targetOffset += 1
    targetOffset += installPublicKey(rawBinary, targetOffset, definingPublicKey, useCompressedKeys)
    rawBinary(targetOffset) = definingRole.toByte
    targetOffset += 1
    targetOffset += installPublicKey(rawBinary, targetOffset, sourcePublicKey, useCompressedKeys)
    rawBinary(targetOffset + 0) = sourceRole1.toByte
    rawBinary(targetOffset + 1) = sourceRole2.toByte
    targetOffset += 2

    val signature = createSignature(rawBinary, definingPrivateKey)
    rawBinary ++ signature
  }

  
  /**
   * Create a certificate an intersection credential. The public and private keys of the defining entity must be present
   * in the database. The public keys of the source entities and the role identifiers must also be present in the
   * database.
   * 
   * @param definingEntity The name of the entity issuing this certificate.
   * @param definingRoleName The name of the role being specified by the issuing entity.
   * @param sourceEntity1 The name of the first entity in the intersection.
   * @param sourceRole1Name The name of entity 1's role.
   * @param sourceEntity2 The name of the second entity in the intersection.
   * @param sourceRole2Name The name of entity 2's role.
   * @param useCompressedKeys True if the public keys should be output in compressed form.
   */
  def createIntersectionCertificate(
    definingEntity:    String,
    definingRoleName:  String,
    sourceEntity1:     String,
    sourceRole1Name:   String,
    sourceEntity2:     String,
    sourceRole2Name:   String,
    useCompressedKeys: Boolean = false) = {
    
    var targetOffset = 0

    val definingPrivateKey = lookupPrivateKey(definingEntity)
    val definingPublicKey  = lookupPublicKey(definingEntity)
    val sourcePublicKey1   = lookupPublicKey(sourceEntity1)
    val sourcePublicKey2   = lookupPublicKey(sourceEntity2)
    val definingRole       = lookupRoleID(definingRoleName)
    val sourceRole1        = lookupRoleID(sourceRole1Name)
    val sourceRole2        = lookupRoleID(sourceRole2Name)

    val rawBinary = new Array[Byte](if (useCompressedKeys) 67 else 124)

    rawBinary(targetOffset) = 4    // Certificate form identifier.
    targetOffset += 1
    targetOffset += installPublicKey(rawBinary, targetOffset, definingPublicKey, useCompressedKeys)
    rawBinary(targetOffset) = definingRole.toByte
    targetOffset += 1
    targetOffset += installPublicKey(rawBinary, targetOffset, sourcePublicKey1, useCompressedKeys)
    rawBinary(targetOffset) = sourceRole1.toByte
    targetOffset += 1
    targetOffset += installPublicKey(rawBinary, targetOffset, sourcePublicKey2, useCompressedKeys)
    rawBinary(targetOffset) = sourceRole2.toByte
    targetOffset += 1

    val signature = createSignature(rawBinary, definingPrivateKey)
    rawBinary ++ signature
  }

  
  /**
   * Sign a message. The signatures returned by this method are in a special low overhead form with zero "extra" bytes.
   * Such signatures do not conform to any published standard but they do save space in memory constrained systems such
   * as wireless sensor networks.
   * 
   * @param message The message to sign. The message can be arbitrary binary data.
   * @param privateKey The key used to make the signature.
   * @return The signature for the message. The message itself is not returned.
   */
  def createSignature(message: Array[Byte], privateKey: ECPrivateKey): Array[Byte] = {
    val ECDSASignature = Signature.getInstance("ECDSA", "BC")
    ECDSASignature.initSign(privateKey)

    // The call to update() processes the data that is passed in. Nothing is output until the call to sign().
    ECDSASignature.update(message)

    // Return the resulting signature.
    val signature = ECDSASignature.sign()

    BinaryHelpers.normalizeSignatureValue(signature)
  }
   
  
  /**
   * Verify the signature on a message.
   * 
   * TODO: It is likely that the signature expected by this method is a "regular" standard format signature and not the
   * special low overhead signatures created by createSignature.
   * 
   * @param message The message to verify.
   * @param signature The signature associated with the message.
   * @param publicKey The public key corresponding to the private key used to make the signature.
   * 
   * @throws Exception if the signature failed to verify, otherwise return normally.
   */
  def verifySignature(message: Array[Byte], signature: Array[Byte], publicKey: ECPublicKey) {
    val ECDSAVerifier = Signature.getInstance("ECDSA","BC")
    ECDSAVerifier.initVerify(publicKey)

    // Pass the message to be verified.
    ECDSAVerifier.update(message, 0, message.length)

    // Pass the signature.
    val verified = ECDSAVerifier.verify(signature)

    if (!verified) {
      throw new Exception("Failure Signature was not verified")
    }
    println("Test Successful!")
  }
  
}
